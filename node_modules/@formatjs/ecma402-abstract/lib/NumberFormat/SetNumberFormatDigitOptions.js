import { DefaultNumberOption } from '../DefaultNumberOption';
import { GetNumberOption } from '../GetNumberOption';
import { GetOption } from '../GetOption';
import { invariant } from '../utils';
var VALID_ROUNDING_INCREMENTS = new Set([
    1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, 5000,
]);
/**
 * https://tc39.es/ecma402/#sec-setnfdigitoptions
 */
export function SetNumberFormatDigitOptions(internalSlots, opts, mnfdDefault, mxfdDefault, notation) {
    var mnid = GetNumberOption(opts, 'minimumIntegerDigits', 1, 21, 1);
    var mnfd = opts.minimumFractionDigits;
    var mxfd = opts.maximumFractionDigits;
    var mnsd = opts.minimumSignificantDigits;
    var mxsd = opts.maximumSignificantDigits;
    internalSlots.minimumIntegerDigits = mnid;
    var roundingIncrement = GetNumberOption(opts, 'roundingIncrement', 1, 5000, 1);
    invariant(VALID_ROUNDING_INCREMENTS.has(roundingIncrement), "Invalid rounding increment value: ".concat(roundingIncrement, ".\nValid values are ").concat(Array.from(VALID_ROUNDING_INCREMENTS).join(', '), "."));
    var roundingMode = GetOption(opts, 'roundingMode', 'string', [
        'ceil',
        'floor',
        'expand',
        'trunc',
        'halfCeil',
        'halfFloor',
        'halfExpand',
        'halfTrunc',
        'halfEven',
    ], 'halfExpand');
    var roundingPriority = GetOption(opts, 'roundingPriority', 'string', ['auto', 'morePrecision', 'lessPrecision'], 'auto');
    var trailingZeroDisplay = GetOption(opts, 'trailingZeroDisplay', 'string', ['auto', 'stripIfInteger'], 'auto');
    if (roundingIncrement !== 1) {
        mxfdDefault = mnfdDefault;
    }
    internalSlots.roundingIncrement = roundingIncrement;
    internalSlots.roundingMode = roundingMode;
    internalSlots.trailingZeroDisplay = trailingZeroDisplay;
    var hasSd = mnsd !== undefined || mxsd !== undefined;
    var hasFd = mnfd !== undefined || mxfd !== undefined;
    var needSd = true;
    var needFd = true;
    if (roundingPriority === 'auto') {
        needSd = hasSd;
        if (hasSd || (!hasFd && notation === 'compact')) {
            needFd = false;
        }
    }
    if (needSd) {
        if (hasSd) {
            internalSlots.minimumSignificantDigits = DefaultNumberOption(mnsd, 1, 21, 1);
            internalSlots.maximumSignificantDigits = DefaultNumberOption(mxsd, internalSlots.minimumSignificantDigits, 21, 21);
        }
        else {
            internalSlots.minimumSignificantDigits = 1;
            internalSlots.maximumSignificantDigits = 21;
        }
    }
    if (needFd) {
        if (hasFd) {
            mnfd = DefaultNumberOption(mnfd, 0, 100, undefined);
            mxfd = DefaultNumberOption(mxfd, 0, 100, undefined);
            if (mnfd === undefined) {
                mnfd = Math.min(mnfdDefault, mxfd !== null && mxfd !== void 0 ? mxfd : 0);
            }
            else if (mxfd === undefined) {
                mxfd = Math.max(mxfdDefault, mnfd);
            }
            else if (mnfd > mxfd) {
                throw new RangeError("Invalid range, ".concat(mnfd, " > ").concat(mxfd));
            }
            internalSlots.minimumFractionDigits = mnfd;
            internalSlots.maximumFractionDigits = mxfd;
        }
        else {
            internalSlots.minimumFractionDigits = mnfdDefault;
            internalSlots.maximumFractionDigits = mxfdDefault;
        }
    }
    if (!needSd && !needFd) {
        internalSlots.minimumFractionDigits = 0;
        internalSlots.maximumFractionDigits = 0;
        internalSlots.minimumSignificantDigits = 1;
        internalSlots.maximumSignificantDigits = 2;
        internalSlots.roundingType = 'morePrecision';
        internalSlots.roundingPriority = 'morePrecision';
    }
    else if (roundingPriority === 'morePrecision') {
        internalSlots.roundingType = 'morePrecision';
        internalSlots.roundingPriority = 'morePrecision';
    }
    else if (roundingPriority === 'lessPrecision') {
        internalSlots.roundingType = 'lessPrecision';
        internalSlots.roundingPriority = 'lessPrecision';
    }
    else if (hasSd) {
        internalSlots.roundingType = 'significantDigits';
        internalSlots.roundingPriority = 'auto';
    }
    else {
        internalSlots.roundingType = 'fractionDigits';
        internalSlots.roundingPriority = 'auto';
    }
    if (roundingIncrement !== 1) {
        invariant(internalSlots.roundingType === 'fractionDigits', 'Invalid roundingType');
        invariant(internalSlots.maximumFractionDigits ===
            internalSlots.minimumFractionDigits, 'With roundingIncrement > 1, maximumFractionDigits and minimumFractionDigits must be equal.');
    }
}
