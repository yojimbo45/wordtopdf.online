"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PartitionNumberPattern = PartitionNumberPattern;
var tslib_1 = require("tslib");
var constants_1 = require("../constants");
var utils_1 = require("../utils");
var ComputeExponent_1 = require("./ComputeExponent");
var format_to_parts_1 = tslib_1.__importDefault(require("./format_to_parts"));
var FormatNumericToString_1 = require("./FormatNumericToString");
/**
 * https://tc39.es/ecma402/#sec-formatnumberstring
 */
function PartitionNumberPattern(numberFormat, x, _a) {
    var _b;
    var getInternalSlots = _a.getInternalSlots;
    var internalSlots = getInternalSlots(numberFormat);
    var pl = internalSlots.pl, dataLocaleData = internalSlots.dataLocaleData, numberingSystem = internalSlots.numberingSystem;
    var symbols = dataLocaleData.numbers.symbols[numberingSystem] ||
        dataLocaleData.numbers.symbols[dataLocaleData.numbers.nu[0]];
    var magnitude = 0;
    var exponent = 0;
    var n;
    if (x.isNaN()) {
        n = symbols.nan;
    }
    else if (!x.isFinite()) {
        n = symbols.infinity;
    }
    else {
        if (!x.isZero()) {
            (0, utils_1.invariant)(x.isFinite(), 'Input must be a mathematical value');
            if (internalSlots.style == 'percent') {
                x = x.times(100);
            }
            ;
            _b = (0, ComputeExponent_1.ComputeExponent)(numberFormat, x, {
                getInternalSlots: getInternalSlots,
            }), exponent = _b[0], magnitude = _b[1];
            x = x.times(constants_1.TEN.pow(-exponent));
        }
        var formatNumberResult = (0, FormatNumericToString_1.FormatNumericToString)(internalSlots, x);
        n = formatNumberResult.formattedString;
        x = formatNumberResult.roundedNumber;
    }
    // Based on https://tc39.es/ecma402/#sec-getnumberformatpattern
    // We need to do this before `x` is rounded.
    var sign;
    var signDisplay = internalSlots.signDisplay;
    switch (signDisplay) {
        case 'never':
            sign = 0;
            break;
        case 'auto':
            if (x.isPositive() || x.isNaN()) {
                sign = 0;
            }
            else {
                sign = -1;
            }
            break;
        case 'always':
            if (x.isPositive() || x.isNaN()) {
                sign = 1;
            }
            else {
                sign = -1;
            }
            break;
        case 'exceptZero':
            if (x.isZero()) {
                sign = 0;
            }
            else if (x.isNegative()) {
                sign = -1;
            }
            else {
                sign = 1;
            }
            break;
        default:
            (0, utils_1.invariant)(signDisplay === 'negative', 'signDisplay must be "negative"');
            if (x.isNegative() && !x.isZero()) {
                sign = -1;
            }
            else {
                sign = 0;
            }
            break;
    }
    return (0, format_to_parts_1.default)({ roundedNumber: x, formattedString: n, exponent: exponent, magnitude: magnitude, sign: sign }, internalSlots.dataLocaleData, pl, internalSlots);
}
